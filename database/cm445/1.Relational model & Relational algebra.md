#### 1. DataBase
数据库是一个有组织的相互关联数据集合，用于建模现实世界的某些方面（例如，建模班级或数字音乐商店中的学生）。人们经常将“数据库”和“数据库管理系统”（例如，MySQL、Oracle、MongoDB、Snowflake ）混淆。数据库管理系统（DBMS）是管理数据库的软件。

考虑一个为数字音乐商店建模的数据库（例如，Spotify）。让数据库保存有关艺术家的信息，以及这些艺术家发行了哪些专辑。

#### 2. 平铺文件假设

数据库存储为DBMS管理的逗号分隔值（CSV）文件。每个实体将存储在其自己的文件中。应用程序每次要读取或更新记录时都必须解析文件。

与数字音乐商店的示例保持一致，将有两个文件：一个用于艺术家，另一个用于专辑。

每个实体都有自己的属性集，因此在每个文件中，不同的记录由新行分隔，而记录中的每个相应属性由逗号分隔。

例如：艺术家可以具有姓名、年份和国家属性，而专辑则具有姓名、艺术家和年份属性。

下面是一个示例CSV文件，了解有关具有模式（名称、年份、国家）的艺术家的信息：

```
Wu-Tang Clan, 1992, USA
Notorious BIG, 1992, USA
GZE, 1990, USA
```

平铺文件存在的问题

- 数据完整性 
  - 我们如何确保每个专辑条目的艺术家都是相同的？
  - 如果有人用无效字符串覆盖专辑年份怎么办？
  - 我们如何对待一张专辑中的多个艺术家？
  - 当我们删除带有专辑的艺术家时，会发生什么？
- 实现
  - 我们怎么找到特定的记录？
  - 如果我们现在想创建一个使用相同数据库的新应用程序，该怎么办？
  - 如果两个线程同时尝试写入同一文件怎么办？
- 持久性
  - 如果在我们的程序更新记录时机器崩溃了怎么办？
  - 如果我们想在多台计算机上复制数据库以实现高可用性，该怎么办

#### 3. DBMS

DBMS是一种允许应用程序存储和分析数据库中信息的软件。通用DBMS旨在允许根据某些数据模型定义、创建、查询、更新和管理数据库。

数据模型是描述数据库中数据的概念的集合。

示例：关系（最常见）、NoSQL（键/值、图）、数组/矩阵/向量

Schema 是基于数据模型对特定数据集合的描述。

**早期的DBMS**

数据库应用程序难以构建和维护，因为逻辑层和物理层之间存在紧密耦合。

逻辑层描述数据库具有哪些实体和属性，而物理层则描述这些实体和属性的存储方式。早期物理层是在应用程序代码中定义的，因此如果我们想更改应用程序使用的物理层，我们必须更改所有代码以匹配新的物理层。

#### 4. 关系模型

Ted Codd注意到，人们每次想改变物理层时都在重写DBMS，所以在1970年，他提出了关系模型来避免这种情况。

关系模型基于关系定义数据库抽象，以避免维护开销。它有三个关键点：

- 将数据库存储在简单的数据结构（关系）中。

-  通过高级语言访问数据，DBMS找出最佳执行策略。
-  物理存储留给DBMS实现。

关系数据模型定义了三个概念：

-  结构：关系的定义及其内容。这是关系具有的属性以及这些属性可以持有的值。

- 完整性：确保数据库的内容满足约束。一个示例约束是，年属性的任何值都必须是数字。
- 操作：如何访问和修改数据库的内容。

关系是一个无序集，它包含表示实体的属性关系。由于关系是无序的，DBMS可以以任何它想要的方式存储它们，从而允许优化。

元组是关系中的一组属性值（也称为其domain）。最初，值必须是原子或标量，但现在值也可以是列表或嵌套数据结构。每个属性都可以是一个特殊值NULL，这意味着对于给定的元组，属性是未定义的。

具有n个属性的关系称为n-ary关系

**Keys**

关系的主键唯一标识单个元组。如果您没有定义内部主键，某些DBMS会自动创建内部主键。许多DBMS都支持自动生成的键，因此应用程序不必手动增加键，但某些DBMS仍然需要主键。

外键指定一个关系中的属性必须映射到另一个关系中的元组。



#### 5. DMLs

从数据库存储和检索信息的方法。有两类语言可用于此：

- 过程：查询指定DBMS应使用的（高级）策略来根据集/包查找所需的结果。（关系代数）
- 非过程性（声明性）：查询仅指定需要的数据，而不是如何查找数据。（关系微积分）

#### 6. 关系代数

关系代数是一组基本操作，用于检索和操作关系中的元组。每个运算符都接受一个或多个关系作为输入，并输出一个新的关系。要编写查询，我们可以将这些运算符“链接”在一起，以创建更复杂的操作。

**Select**

Select接受关系，并从该关系中输出满足选择谓词的元组子集。谓词的作用就像一个过滤器，我们可以使用连词和析取组合多个谓词。

语法：$\sigma_{predicate}(R)$

示例：:$\sigma_{id=’a2}’(R)$

SQL: `SELECT * FROM R WHERE id = 'a2'`

**Projection**

投影接受关系，并输出具有仅包含指定属性的元组的关系。您可以重新排列输入关系中属性的顺序以及操作值。

语法：$\pi_{A1,A2...,An}(R)$

示例：:$\pi_{num-100,id}(\sigma_{id='a2'}(R))$

SQL: `SELECT num-100, id FROM R WHERE id = 'a2'`

**Union**

**Union**接收两个关系，并输出一个关系，该关系包含至少一个输入关系中出现的所有元组。注意：两个输入关系必须具有完全相同的属性。

语法： $(R \cup S)$

SQL：`(SELECT * FROM R) UNION ALL (SELECT * FROM S`)

**Intersection**

交集接收两个关系，并输出一个关系，该关系包含两个输入关系中出现的所有元组。注意：两个输入关系必须具有完全相同的属性。

语法： $(R \cap S)$

SQL：(SELECT * FROM R) INTERSECT (SELECT * FROM S)

**Difference**

差集采用两个关系，并输出一个关系，该关系包含出现在第一个关系中但不出现在第二个关系中的所有元组。注意：两个输入关系必须具有完全相同的属性。

语法： $(R - S)$

SQL：`(SELECT * FROM R) EXCEPT (SELECT * FROM S)`

**Product**

Product接受两个关系，并输出一个关系，该关系包含输入关系中元组的所有可能组合。

语法： $(R \times  S)$

SQL：`: (SELECT * FROM R) CROSS JOIN (SELECT * FROM S), or simply SELECT * FROM R, S`

**Join**

Join接受两个关系，并输出一个关系，该关系包含两个元组的组合，其中对于两个关系共享的每个属性，两个元组的该属性的值是相同的。

语法：$(R\Join S)$

SQL：`SELECT * FROM R JOIN S USING (ATTRIBUTE1, ATTRIBUTE2...)`

**总结**

关系代数是一种过程语言，因为它定义了如何计算查询的高级步骤。例如，$\sigma_{id}=102 (R \Join S)$是说首先执行R和S的连接，然后执行选择，而$(R \Join (\sigma_{id}=102(S)))$将首先在S上执行选择，然后执行连接。这两个语句实际上会产生相同的答案，但如果在1,000,000,000元组中只有1个id=102的元组，则后者明显快于前者。

更好的方法是说出您想要从R和S中检索连接的元组，其中id等于102的结果，并让DBMS决定它想采取的步骤来计算查询。SQL将完全做到这一点，这也是在关系模型数据库上查询的标准。

Prof. Andy Pavlo (http://www.cs.cmu.edu/~pavlo/)
Slides: https://15445.courses.cs.cmu.edu/fall2019/slides/
Notes https://15445.courses.cs.cmu.edu/fall2019/notes/

