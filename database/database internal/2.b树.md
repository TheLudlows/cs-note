
- [1. 文件格式](#1-文件格式)
  - [1.1 slotted page](#11-slotted-page)
  - [1.2 slot layout](#12-slot-layout)
  - [1.3 page layout](#13-page-layout)
  - [1.3 空间管理](#13-空间管理)
- [2. B树的实现](#2-b树的实现)
  - [2.1 页头](#21-页头)
  - [2.2 搜索](#22-搜索)
  - [2.3 分裂与合并](#23-分裂与合并)
  - [2.4 平衡](#24-平衡)
  - [2.5 压缩](#25-压缩)
  - [2.6 GC](#26-gc)
#### 1. 文件格式
大多数原地更新的存储结构都是用相同大小的页，从而简化了读取和写入访问，仅追加的存储结构同堂也按页写入，一旦内存中的页写满，就将其写到磁盘，文件通常以定长的header开始，一般也已定长的tailer结束，尾部包含访问文件件的辅助信息，文件件的其余部分被分为多个页。
![](file.png)
存储数据或者索引的页通常是文件存储系统块的整数倍，一般是4~16K，在B树张中节点分为叶节点和非叶节点，每个B树节点占据一个页或者多个链接在一起的页，因此节点和页通常等价。
##### 1.1 slotted page
页格式的挑战主要在于
1. 空间管理，回收删除的记录
2. 较小的代价保存变长的记录
3. 动态的布局，空间回收移动数据后不改变对记录的引用

一般将页分为多个slot（cell），并且每个slot都有一个指针只想它，这些指针集中在文件头部
![](slot-page.png)
页头部包含了页和slot的重要信息，slot的大小可以不同，可以不保存任意数据，比如键、数据记录、指针等。
对于上面的三个挑战
1. 对于空间管理，对slot进行整理重写，就可以回收空间
2. slotter page只额外存储一个指针数据
3. 外部的引用通过slot id来引用记录，不关心记录的具体位置

##### 1.2 slot layout
slot或cell（单元格）组合成页，页组合成树，slot分为键单元格和键值单元格。键单元格包含一个分隔键和一个指针，该指针指向两个相邻键之间的页，键值单元格包含键和关联的数据记录。
假定一个页内的所有单元格都是统一的，页内的单元格的元数据只需要保存一份。
构成一个单元格的数据局如下：
- 单元格类型（可以从页元数据推断）
- 键长度
- 子页ID
- 键的数据
  键值单元格存放数据记录，和键单元格类似
  - 单元格类型（页的元数据推断）
  - 键的长度
  - 值得长度
  - 键的数据
  - 值得数据
  
##### 1.3 page layout
单元格放在页的右边，头和指针数组放在页的左边，新插的数据向左边增长。
![](page-layout.png)
其中记录的顺序通过调整指针的顺序来实现逻辑上的顺序。这种设计可以使在页中添加数据不需要移动其他记录。
假如页中已有Tomhe 和Leslie这两条数据，这两个名字，这两个名字的逻辑顺序与插入顺序不同，但是指针被重新排序，以便于二分查找。
![](pointer.png)
现在假如新的名字Ron，新数据假如可用空间的末端，但是指针必须保持记录的字典序：Leslie、ROn、Tom，为此重新排序指针：将插入节点之后的指针向右移动
![](pointer2.png)
##### 1.3 空间管理
从页中删除一条记录秩序将这个单元格标记为删除，并根据释放的空间大小和指针更新可用列表，这个列表保存了可用短的偏移量以及大小，每当插入新的单元格时，会检查可用列表。
至于新插入的记录使用哪个空闲空可以有两种策略
1. 首次适配优先，即吧数据填入第一个合适的段
2. 最佳适配优先，寻找的段使得剩余空间最小
如果找不到合适的空闲空间存放新的单元格，但是有足够多的碎片空间，那么会进行碎片整理，以回收空间。
#### 2. B树的实现

##### 2.1 页头
页头保存了有关定位、优化等信息，，通常包含页中单元格的数量，空间空间的上下界偏移量等元数据，PGSQL在头部存储页大小和布局版本，MySQL InnoDB中保存记录总数、层数等信息。

- 同级指针
一些实现中页头存储了前序和后继指针，指向同级的页，这给分裂和合并增加了一些复杂度，当一个非最右节点拆分时，之前指向分裂前的指针就必须重新指向新创建的节点。优势就是同级节点的遍历会方便很多。

- 最右指针
- 节点高键
- 溢出页
##### 2.2 搜索
##### 2.3 分裂与合并
##### 2.4 平衡
##### 2.5 压缩
##### 2.6 GC